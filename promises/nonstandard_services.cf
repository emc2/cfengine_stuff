# Duplicates standard_services, expanded to handle freebsd and other
# OSes.  Includes entries to manage services configured by this
# package.
body service_method nonstandard_service
{
      service_bundle => nonstandard_services("$(this.promiser)",
                                             "$(this.service_policy)");
}

body contain useshell
{
  useshell => "useshell";
}

bundle agent nonstandard_services(service, state) {
  vars:
      "stakeholders[postfix]" slist => { "smtp_in" };
      "stakeholders[ssh]" slist => { "ssh_in" };
      "stakeholders[nfs]" slist => { "nfsd_in" };

    freebsd::
      # sshd
      "startcommand[ssh]" string => "/usr/sbin/service sshd start";
      "restartcommand[ssh]" string => "/usr/sbin/service sshd restart";
      "reloadcommand[ssh]" string => "/usr/sbin/service sshd restart";
      "stopcommand[ssh]" string => "/usr/sbin/service sshd stop";
      "statuscommand[ssh]" string => "/usr/sbin/service sshd status";

      # nslcd
      "startcommand[nslcd]" string => "/usr/sbin/service nslcd start";
      "restartcommand[nslcd]" string => "/usr/sbin/service nslcd restart";
      "reloadcommand[nslcd]" string => "/usr/sbin/service nslcd restart";
      "stopcommand[nslcd]" string => "/usr/sbin/service nslcd stop";
      "statuscommand[nslcd]" string => "/usr/sbin/service nslcd status";

      # kerberos
      "startcommand[kerberos]" string => "/usr/sbin/service kerberos start";
      "restartcommand[kerberos]" string => "/usr/sbin/service kerberos restart";
      "reloadcommand[kerberos]" string => "/usr/sbin/service kerberos restart";
      "stopcommand[kerberos]" string => "/usr/sbin/service kerberos stop";
      "statuscommand[kerberos]" string => "/usr/sbin/service kerberos status";

      # kadmin
      "startcommand[kadmin]" string => "/usr/sbin/service kadmind start";
      "restartcommand[kadmin]" string => "/usr/sbin/service kadmind restart";
      "reloadcommand[kadmin]" string => "/usr/sbin/service kadmind restart";
      "stopcommand[kadmin]" string => "/usr/sbin/service kadmind stop";
      "statuscommand[kadmin]" string => "/usr/sbin/service kadmind status";

      # saslauthd
      "startcommand[sasl]" string => "/usr/sbin/service saslauthd start";
      "restartcommand[sasl]" string => "/usr/sbin/service saslauthd restart";
      "reloadcommand[sasl]" string => "/usr/sbin/service saslauthd restart";
      "stopcommand[sasl]" string => "/usr/sbin/service saslauthd stop";
      "statuscommand[sasl]" string => "/usr/sbin/service saslauthd status";

      # slapd
      "startcommand[ldap]" string => "/usr/sbin/service slapd start";
      "restartcommand[ldap]" string => "/usr/sbin/service slapd restart";
      "reloadcommand[ldap]" string => "/usr/sbin/service slapd restart";
      "stopcommand[ldap]" string => "/usr/sbin/service slapd stop";
      "statuscommand[ldap]" string => "/usr/sbin/service slapd status";

      # postgresql
      "startcommand[postgresql]" string => "/usr/sbin/service postgresql start";
      "restartcommand[postgresql]" string => "/usr/sbin/service postgresql restart";
      "reloadcommand[postgresql]" string => "/usr/sbin/service postgresql restart";
      "stopcommand[postgresql]" string => "/usr/sbin/service postgresql stop";
      "statuscommand[postgresql]" string => "/usr/sbin/service postgresql status";

  classes:
      "start" expression => strcmp("start","$(state)"),
      comment => "Check if to start a service";
      "restart" expression => strcmp("restart","$(state)"),
      comment => "Check if to restart a service";
      "reload" expression => strcmp("reload","$(state)"),
      comment => "Check if to reload a service";
      "stop"  expression => strcmp("stop","$(state)"),
      comment => "Check if to stop a service";

  commands:
      "$(statuscommand[$(service)]) > /dev/null && echo '+$(service)_running' || echo '+$(service)_stopped'"
      contain => useshell,
      module => "true";

    start::
      "$(startcommand[$(service)])"
      comment => "Execute command to start the $(service) service",
      ifvarclass => canonify("$(service)_stopped");

    stop::
      "$(stopcommand)"
      comment => "Execute command to stop the $(service) service",
      ifvarclass => "$(service)_running";

    restart::
      "$(restartcommand[$(service)])"
      comment => "Execute command to restart the $(service) service";

    reload::
      "$(reloadcommand[$(service)])"
      comment => "Execute command to reload the $(service) service";
}
